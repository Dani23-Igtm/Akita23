import os
import time
from flask import Flask, render_template, request, jsonify
import yt_dlp as youtube_dl
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
import subprocess

app = Flask(__name__)

# Función para guardar cookies en un archivo compatible con yt-dlp
def save_cookies(driver, filename):
    cookies = driver.get_cookies()
    with open(filename, "w") as file:
        file.write("# Netscape HTTP Cookie File\n")
        file.write("# This file is generated by Selenium. Do not edit.\n\n")
        for cookie in cookies:
            file.write(
                f"{cookie['domain']}\t"
                f"{'TRUE' if cookie['domain'].startswith('.') else 'FALSE'}\t"
                f"{cookie['path']}\t"
                f"{'TRUE' if cookie.get('secure', False) else 'FALSE'}\t"
                f"{cookie.get('expiry', 0)}\t"
                f"{cookie['name']}\t"
                f"{cookie['value']}\n"
            )
    print(f"[INFO] Cookies guardadas en: {filename}")

# Función para ejecutar el comando de yt-dlp
def run_yt_dlp(cookies_path, referer, vimeo_url):
    # Ruta de la carpeta de salida
    output_path = r"C:\Users\USER\Videos\webdas\DescargadorDeVideos\output"
    if not os.path.exists(output_path):
        os.makedirs(output_path)

    # El comando yt-dlp con los valores reemplazados
    command = [
        "yt-dlp",
        f"--cookies={cookies_path}",  # Corregir el formato de --cookies
        f"--referer={referer}",
        "--concurrent-fragments=10",
        "-o", os.path.join(output_path, "%(title)s.%(ext)s"),  # Usamos la ruta de salida correcta
        "--hls-prefer-native",
        vimeo_url
    ]
    
    # Ejecutar el comando en el sistema
    try:
        subprocess.run(command, check=True)
        print("[INFO] Video descargado exitosamente.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Error al ejecutar yt-dlp: {e}")
        return False

# Función para descargar el video
def download_video(video_url):
    options = webdriver.ChromeOptions()
    options.add_argument("--headless")  # Ejecutar el navegador sin interfaz gráfica
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)

    try:
        # Navegar a la página de login
        login_url = "https://uc.osinergmin.gob.pe/login/index.php"
        driver.get(login_url)
        
        # Completar login (usuario y contraseña)
        username = "76075474"  # Usa un valor adecuado o pásalo como parámetro
        password = "perralacy28"  # Usa un valor adecuado o pásalo como parámetro
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.NAME, "username"))).send_keys(username)
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.NAME, "password"))).send_keys(password)
        driver.find_element(By.NAME, "password").send_keys("\n")
        time.sleep(2)  # Esperar para que la página cargue completamente

        # Navegar a la URL del video
        print("[INFO] Navegando a la URL del video...")
        driver.get(video_url)

        # Esperar explícitamente a que el iframe esté presente
        iframe = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.TAG_NAME, "iframe"))
        )
        vimeo_url = iframe.get_attribute("src")

        # Guardar cookies
        cookies_path = r"C:\Users\USER\Videos\webdas\DescargadorDeVideos\cookies.txt"
        save_cookies(driver, cookies_path)

        # Ejecutar el comando de yt-dlp para descargar el video
        referer = video_url  # El referer es la misma URL de la página del video
        if run_yt_dlp(cookies_path, referer, vimeo_url):
            return True  # Si todo sale bien

        return False  # Si hubo un error en la descarga

    except Exception as e:
        print(f"[ERROR] Ocurrió un error: {e}")
        return False
    finally:
        driver.quit()

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        video_url = request.form["video_url"]
        # Ejecutar la descarga en un hilo separado para no bloquear la UI
        if download_video(video_url):
            return render_template("index.html", message="¡Descarga completa! El video se guardó en la carpeta 'output'.")
        else:
            return render_template("index.html", message="Error al descargar el video.")

    return render_template("index.html")

if __name__ == "__main__":
    app.run(debug=True)
